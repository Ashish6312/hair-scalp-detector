{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Camera Capture - Hair & Scalp AI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Poppins", sans-serif;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        color: white;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        overflow: auto;
      }

      .camera-header {
        background: rgba(15, 23, 42, 0.95);
        backdrop-filter: blur(10px);
        padding: 1.25rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      }
      .camera-header h1 {
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        color: #f1f5f9;
        font-weight: 600;
      }
      .camera-header h1 i {
        color: #14b8a6;
        font-size: 1.3rem;
      }
      .close-btn {
        background: rgba(239, 68, 68, 0.1);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.3);
        width: 40px;
        height: 40px;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        transition: all 0.3s;
      }
      .close-btn:hover {
        background: rgba(239, 68, 68, 0.2);
        border-color: #ef4444;
        transform: translateY(-2px);
      }

      .camera-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        padding-bottom: 200px;
        position: relative;
      }

      .camera-view {
        position: relative;
        width: 100%;
        max-width: 640px;
        aspect-ratio: 4/3;
        background: #000;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5),
                    0 0 0 1px rgba(20, 184, 166, 0.1),
                    inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        border: 3px solid transparent;
        background-clip: padding-box;
        position: relative;
      }

      .camera-view::before {
        content: '';
        position: absolute;
        top: -3px;
        left: -3px;
        right: -3px;
        bottom: -3px;
        background: linear-gradient(135deg, #14b8a6 0%, #10b981 50%, #14b8a6 100%);
        border-radius: 20px;
        z-index: -1;
        opacity: 0.3;
        animation: borderGlow 3s ease-in-out infinite;
      }

      @keyframes borderGlow {
        0%, 100% {
          opacity: 0.3;
          filter: blur(8px);
        }
        50% {
          opacity: 0.6;
          filter: blur(12px);
        }
      }

      .camera-view.detecting::before {
        opacity: 0.8;
        animation: borderPulse 1.5s ease-in-out infinite;
      }

      @keyframes borderPulse {
        0%, 100% {
          opacity: 0.8;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.02);
        }
      }

      #cameraVideo {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .head-mask-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      /* Professional Circular Detection Zone */
      .detection-circle {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 55%;
        max-width: 380px;
        aspect-ratio: 1;
        border: 3px solid rgba(20, 184, 166, 0.4);
        border-radius: 50%;
        pointer-events: none;
        z-index: 5;
        transition: all 0.4s ease;
        background: radial-gradient(circle, rgba(20, 184, 166, 0.05) 0%, transparent 70%);
      }

      .detection-circle::before {
        content: '';
        position: absolute;
        top: -15px;
        left: -15px;
        right: -15px;
        bottom: -15px;
        border: 1px solid rgba(20, 184, 166, 0.2);
        border-radius: 50%;
        animation: circlePulse 3s ease-in-out infinite;
      }

      .detection-circle::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 4px;
        height: 4px;
        background: rgba(20, 184, 166, 0.6);
        border-radius: 50%;
        box-shadow: 0 0 20px rgba(20, 184, 166, 0.8);
      }

      @keyframes circlePulse {
        0%, 100% {
          transform: scale(1);
          opacity: 0.3;
        }
        50% {
          transform: scale(1.08);
          opacity: 0.6;
        }
      }

      .detection-circle.aligned {
        border-color: #14b8a6;
        border-width: 4px;
        background: radial-gradient(circle, rgba(20, 184, 166, 0.15) 0%, transparent 70%);
        box-shadow: 0 0 40px rgba(20, 184, 166, 0.4),
                    inset 0 0 40px rgba(20, 184, 166, 0.1);
        animation: circleGlow 2s ease-in-out infinite;
      }

      .detection-circle.aligned::before {
        border-color: #14b8a6;
        border-width: 2px;
        opacity: 1;
        animation: circlePulseAligned 2s ease-in-out infinite;
      }

      .detection-circle.aligned::after {
        background: #14b8a6;
        box-shadow: 0 0 30px rgba(20, 184, 166, 1);
        animation: centerPulse 1.5s ease-in-out infinite;
      }

      @keyframes circleGlow {
        0%, 100% {
          box-shadow: 0 0 40px rgba(20, 184, 166, 0.4),
                      inset 0 0 40px rgba(20, 184, 166, 0.1);
        }
        50% {
          box-shadow: 0 0 60px rgba(20, 184, 166, 0.6),
                      inset 0 0 60px rgba(20, 184, 166, 0.2);
        }
      }

      @keyframes circlePulseAligned {
        0%, 100% {
          transform: scale(1);
          opacity: 0.8;
        }
        50% {
          transform: scale(1.05);
          opacity: 1;
        }
      }

      @keyframes centerPulse {
        0%, 100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.5);
          opacity: 0.8;
        }
      }

      /* Detection Zone Label */
      .detection-label {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: rgba(255, 255, 255, 0.8);
        font-size: 0.85rem;
        font-weight: 500;
        text-align: center;
        pointer-events: none;
        z-index: 6;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
        transition: all 0.3s ease;
        letter-spacing: 0.5px;
        padding: 0.5rem;
      }

      .detection-label i {
        font-size: 2rem;
        display: block;
        margin-bottom: 0.5rem;
        opacity: 0.7;
      }

      .detection-label.aligned {
        color: #14b8a6;
        font-size: 0.95rem;
        text-shadow: 0 0 15px rgba(20, 184, 166, 0.8);
        font-weight: 600;
      }

      .detection-label.aligned i {
        opacity: 1;
        animation: iconBounce 0.6s ease-out;
      }

      @keyframes iconBounce {
        0% { transform: scale(0.5); opacity: 0; }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); opacity: 1; }
      }

      /* Realistic Head Mask Container - Hidden for cleaner look */
      .head-mask-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50%;
        max-width: 350px;
        aspect-ratio: 10/13;
        pointer-events: none;
        z-index: 5;
        opacity: 0;
        display: none;
      }

      .head-mask-container svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
      }

      .head-mask-container.aligned #headOutline {
        stroke: #14b8a6;
        stroke-width: 2.5;
        stroke-dasharray: none;
        animation: headPulse 1.5s infinite;
      }

      .head-mask-container.aligned #headFill {
        opacity: 0.2;
        animation: fillPulse 1.5s infinite;
      }

      @keyframes headPulse {
        0%, 100% {
          stroke: #14b8a6;
          filter: drop-shadow(0 0 10px rgba(20, 184, 166, 0.5));
        }
        50% {
          stroke: #10b981;
          filter: drop-shadow(0 0 15px rgba(20, 184, 166, 0.7));
        }
      }

      @keyframes fillPulse {
        0%, 100% { opacity: 0.3; }
        50% { opacity: 0.5; }
      }

      /* Professional Corner Brackets - Hidden for cleaner look */
      .corner-brackets {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 65%;
        max-width: 480px;
        aspect-ratio: 3/4;
        display: none;
      }

      .corner {
        position: absolute;
        width: 50px;
        height: 50px;
        border: 2px solid rgba(255, 255, 255, 0.6);
        transition: all 0.3s ease;
      }

      .corner::before {
        content: '';
        position: absolute;
        width: 8px;
        height: 8px;
        background: rgba(255, 255, 255, 0.8);
      }

      .corner.top-left {
        top: 0;
        left: 0;
        border-right: none;
        border-bottom: none;
        border-top-left-radius: 4px;
      }

      .corner.top-left::before {
        top: -2px;
        left: -2px;
      }

      .corner.top-right {
        top: 0;
        right: 0;
        border-left: none;
        border-bottom: none;
        border-top-right-radius: 4px;
      }

      .corner.top-right::before {
        top: -2px;
        right: -2px;
      }

      .corner.bottom-left {
        bottom: 0;
        left: 0;
        border-right: none;
        border-top: none;
        border-bottom-left-radius: 4px;
      }

      .corner.bottom-left::before {
        bottom: -2px;
        left: -2px;
      }

      .corner.bottom-right {
        bottom: 0;
        right: 0;
        border-left: none;
        border-top: none;
        border-bottom-right-radius: 4px;
      }

      .corner.bottom-right::before {
        bottom: -2px;
        right: -2px;
      }

      .corner.aligned {
        border-color: #14b8a6;
        border-width: 3px;
        animation: cornerPulse 1.5s infinite;
      }

      .corner.aligned::before {
        background: #14b8a6;
        box-shadow: 0 0 8px rgba(20, 184, 166, 0.6);
      }

      @keyframes cornerPulse {
        0%, 100% { 
          border-color: #14b8a6;
          box-shadow: 0 0 12px rgba(20, 184, 166, 0.4);
        }
        50% { 
          border-color: #10b981;
          box-shadow: 0 0 20px rgba(20, 184, 166, 0.6);
        }
      }

      /* Realistic 3D Polygonal Mesh Overlay - Subtle */
      .mesh-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 55%;
        max-width: 380px;
        aspect-ratio: 1;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.8s ease;
        filter: drop-shadow(0 0 8px rgba(20, 184, 166, 0.3));
        border-radius: 50%;
        overflow: hidden;
      }

      .mesh-overlay.active {
        opacity: 0.4;
        animation: meshGlow 3s ease-in-out infinite;
      }

      @keyframes meshGlow {
        0%, 100% {
          filter: drop-shadow(0 0 8px rgba(20, 184, 166, 0.3));
          opacity: 0.4;
        }
        50% {
          filter: drop-shadow(0 0 15px rgba(20, 184, 166, 0.5));
          opacity: 0.5;
        }
      }

      .mesh-overlay canvas {
        width: 100%;
        height: 100%;
      }

      /* Grid Overlay - Hidden for cleaner look */
      .grid-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 70%;
        max-width: 500px;
        aspect-ratio: 3/4;
        opacity: 0;
        pointer-events: none;
        display: none;
      }

      .grid-overlay svg {
        width: 100%;
        height: 100%;
      }

      .grid-overlay.aligned {
        opacity: 0.4;
        animation: gridPulse 2s infinite;
      }

      @keyframes gridPulse {
        0%, 100% { opacity: 0.4; }
        50% { opacity: 0.6; }
      }

      /* Scanning Line - Subtle and Professional */
      .scan-line {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, 
          transparent 0%, 
          rgba(20, 184, 166, 0.3) 20%, 
          rgba(20, 184, 166, 0.8) 50%, 
          rgba(20, 184, 166, 0.3) 80%, 
          transparent 100%);
        box-shadow: 0 0 15px rgba(20, 184, 166, 0.6);
        animation: scan 4s ease-in-out infinite;
        opacity: 0;
      }

      .scan-line.active {
        opacity: 0.6;
      }

      @keyframes scan {
        0% { 
          transform: translateY(0);
          opacity: 0;
        }
        5% {
          opacity: 0.6;
        }
        95% {
          opacity: 0.6;
        }
        100% { 
          transform: translateY(100%);
          opacity: 0;
        }
      }

      /* Particle effects */
      .particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.5s;
      }

      .particles.active {
        opacity: 1;
      }

      .particle {
        position: absolute;
        width: 3px;
        height: 3px;
        background: #14b8a6;
        border-radius: 50%;
        box-shadow: 0 0 6px #14b8a6;
        animation: float 4s ease-in-out infinite;
      }

      @keyframes float {
        0%, 100% {
          transform: translateY(0) translateX(0);
          opacity: 0;
        }
        10% {
          opacity: 1;
        }
        90% {
          opacity: 1;
        }
        100% {
          transform: translateY(-100px) translateX(20px);
          opacity: 0;
        }
      }

      .mask-instructions {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(15, 23, 42, 0.92);
        backdrop-filter: blur(15px);
        color: #e2e8f0;
        padding: 1rem 2rem;
        font-size: 0.9rem;
        text-align: center;
        max-width: 85%;
        font-weight: 500;
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 12px;
        transition: all 0.4s ease;
        box-shadow: 0 8px 16px -4px rgba(0, 0, 0, 0.3);
        letter-spacing: 0.3px;
      }

      .mask-instructions.ready {
        background: rgba(20, 184, 166, 0.2);
        color: #14b8a6;
        border-color: rgba(20, 184, 166, 0.6);
        box-shadow: 0 0 30px rgba(20, 184, 166, 0.4);
        transform: translateX(-50%) scale(1.05);
        font-weight: 600;
      }

      .capture-countdown {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 8rem;
        color: #c3ff00;
        font-weight: 300;
        text-shadow: 0 0 30px #c3ff00, 0 0 60px #c3ff00;
        display: none;
        z-index: 10;
        font-family: 'Courier New', monospace;
      }

      .capture-countdown.active {
        display: block;
        animation: countdownPulse 1s ease-in-out;
      }

      @keyframes countdownPulse {
        0% { 
          transform: translate(-50%, -50%) scale(0.5); 
          opacity: 0; 
        }
        50% { 
          transform: translate(-50%, -50%) scale(1.2); 
          opacity: 1; 
        }
        100% { 
          transform: translate(-50%, -50%) scale(1); 
          opacity: 1; 
        }
      }

      .camera-controls-panel {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        background: rgba(15, 23, 42, 0.95);
        backdrop-filter: blur(15px);
        padding: 1.5rem 2rem;
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3),
                    0 0 0 1px rgba(20, 184, 166, 0.1);
        min-width: 360px;
        z-index: 50;
      }

      .mode-toggle {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.75rem 1.25rem;
        background: rgba(30, 41, 59, 0.5);
        border-radius: 8px;
        border: 1px solid rgba(148, 163, 184, 0.15);
      }

      .mode-label {
        font-size: 0.875rem;
        color: #cbd5e1;
        font-weight: 500;
      }

      .toggle-switch {
        position: relative;
        width: 56px;
        height: 28px;
        background: rgba(100, 116, 139, 0.3);
        border-radius: 14px;
        cursor: pointer;
        transition: all 0.3s;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .toggle-switch.active {
        background: #14b8a6;
        border-color: #14b8a6;
      }

      .toggle-slider {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 50%;
        transition: transform 0.3s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .toggle-switch.active .toggle-slider {
        transform: translateX(28px);
      }

      .capture-button {
        width: 100%;
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #14b8a6, #10b981);
        color: white;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        transition: all 0.3s;
        box-shadow: 0 4px 6px -1px rgba(20, 184, 166, 0.3);
      }

      .capture-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(20, 184, 166, 0.4);
      }

      .capture-button:active {
        transform: translateY(0);
      }

      .capture-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .camera-status {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        color: #cbd5e1;
        font-size: 0.875rem;
        font-weight: 500;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #64748b;
        animation: blink 1.5s infinite;
        position: relative;
      }

      .status-dot::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid rgba(100, 116, 139, 0.3);
        animation: ripple 1.5s infinite;
      }

      .status-dot.scanning {
        background: #14b8a6;
        box-shadow: 0 0 10px rgba(20, 184, 166, 0.5);
      }

      .status-dot.scanning::after {
        border-color: rgba(20, 184, 166, 0.5);
      }

      @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
      }

      @keyframes ripple {
        0% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(2);
          opacity: 0;
        }
      }

      .progress-bar {
        width: 100%;
        height: 6px;
        background: rgba(148, 163, 184, 0.2);
        border-radius: 10px;
        overflow: hidden;
        display: none;
        position: relative;
      }

      .progress-bar.active {
        display: block;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #14b8a6, #10b981);
        width: 0%;
        transition: width 0.3s ease;
        box-shadow: 0 0 10px rgba(20, 184, 166, 0.5);
        position: relative;
        border-radius: 10px;
      }

      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 200;
      }

      .loading-overlay.active {
        display: flex;
      }

      .loading-content {
        text-align: center;
      }

      .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(195, 255, 0, 0.3);
        border-top-color: #c3ff00;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1rem;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      /* Camera Flash Effect */
      .flash-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #fff;
        opacity: 0;
        pointer-events: none;
        z-index: 150;
      }

      .flash-overlay.active {
        animation: flash 0.5s ease-out;
      }

      @keyframes flash {
        0% { opacity: 0; }
        10% { opacity: 1; }
        100% { opacity: 0; }
      }

      /* Capture Effect */
      .capture-effect {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: 5px solid #c3ff00;
        box-shadow: inset 0 0 50px #c3ff00, 0 0 50px #c3ff00;
        opacity: 0;
        pointer-events: none;
        z-index: 140;
      }

      .capture-effect.active {
        animation: captureGlow 0.5s ease-out;
      }

      @keyframes captureGlow {
        0% { opacity: 0; transform: scale(1); }
        50% { opacity: 1; transform: scale(0.98); }
        100% { opacity: 0; transform: scale(1); }
      }

      canvas {
        display: none;
      }

      /* Confirmation Screen */
      .confirmation-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(10px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 300;
        padding: 2rem;
      }

      .confirmation-screen.active {
        display: flex;
      }

      .confirmation-content {
        background: rgba(15, 23, 42, 0.98);
        border-radius: 16px;
        padding: 2rem;
        max-width: 500px;
        width: 100%;
        border: 1px solid rgba(148, 163, 184, 0.2);
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      }

      .confirmation-header {
        text-align: center;
        margin-bottom: 1.5rem;
      }

      .confirmation-header h2 {
        font-size: 1.5rem;
        color: #f1f5f9;
        margin-bottom: 0.5rem;
        font-weight: 600;
      }

      .confirmation-header p {
        color: #94a3b8;
        font-size: 0.875rem;
      }

      .preview-image-container {
        width: 100%;
        aspect-ratio: 4/3;
        border-radius: 12px;
        overflow: hidden;
        margin-bottom: 1.5rem;
        border: 2px solid rgba(148, 163, 184, 0.2);
        background: #000;
      }

      .preview-image-container img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .confirmation-buttons {
        display: flex;
        gap: 1rem;
      }

      .confirm-btn {
        flex: 1;
        padding: 1rem;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
      }

      .confirm-btn-use {
        background: linear-gradient(135deg, #14b8a6, #10b981);
        color: white;
        box-shadow: 0 4px 6px -1px rgba(20, 184, 166, 0.3);
      }

      .confirm-btn-use:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(20, 184, 166, 0.4);
      }

      .confirm-btn-retake {
        background: rgba(239, 68, 68, 0.1);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      .confirm-btn-retake:hover {
        background: rgba(239, 68, 68, 0.2);
        border-color: #ef4444;
      }
    </style>
  </head>
  <body>
    <div class="camera-header">
      <h1><i class="fas fa-camera"></i> Capture Image</h1>
      <button class="close-btn" id="closeBtn">
        <i class="fas fa-times"></i>
      </button>
    </div>

    <div class="camera-container">
      <div class="camera-view">
        <video id="cameraVideo" autoplay playsinline></video>
        <canvas id="captureCanvas"></canvas>
        
        <div class="head-mask-overlay">
          <!-- Circular Detection Zone -->
          <div class="detection-circle" id="detectionCircle">
            <!-- Corner markers for the circle -->
            <div class="circle-marker" style="position: absolute; top: -5px; left: 50%; transform: translateX(-50%); width: 30px; height: 3px; background: rgba(20, 184, 166, 0.6); border-radius: 2px;"></div>
            <div class="circle-marker" style="position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); width: 30px; height: 3px; background: rgba(20, 184, 166, 0.6); border-radius: 2px;"></div>
            <div class="circle-marker" style="position: absolute; left: -5px; top: 50%; transform: translateY(-50%); width: 3px; height: 30px; background: rgba(20, 184, 166, 0.6); border-radius: 2px;"></div>
            <div class="circle-marker" style="position: absolute; right: -5px; top: 50%; transform: translateY(-50%); width: 3px; height: 30px; background: rgba(20, 184, 166, 0.6); border-radius: 2px;"></div>
          </div>
          <div class="detection-label" id="detectionLabel">
            <i class="fas fa-head-side-virus"></i>
            Position Head/Scalp Here
          </div>

          <!-- Realistic Head Mask Overlay -->
          <div class="head-mask-container" id="headMaskContainer">
            <svg viewBox="0 0 100 130" preserveAspectRatio="none">
              <!-- Head outline shape -->
              <defs>
                <linearGradient id="maskGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                  <stop offset="0%" style="stop-color:rgba(255,255,255,0.3);stop-opacity:1" />
                  <stop offset="100%" style="stop-color:rgba(255,255,255,0.1);stop-opacity:1" />
                </linearGradient>
              </defs>
              
              <!-- Head shape path -->
              <path id="headOutline" d="
                M 50 10
                C 35 10, 25 20, 25 35
                C 25 45, 20 55, 20 65
                C 20 75, 22 85, 25 95
                C 28 105, 35 115, 40 120
                C 43 123, 46 125, 50 125
                C 54 125, 57 123, 60 120
                C 65 115, 72 105, 75 95
                C 78 85, 80 75, 80 65
                C 80 55, 75 45, 75 35
                C 75 20, 65 10, 50 10 Z
              " 
              fill="none" 
              stroke="rgba(255, 255, 255, 0.6)" 
              stroke-width="1.5"
              stroke-dasharray="5,3"/>
              
              <!-- Fill indicator -->
              <path id="headFill" d="
                M 50 10
                C 35 10, 25 20, 25 35
                C 25 45, 20 55, 20 65
                C 20 75, 22 85, 25 95
                C 28 105, 35 115, 40 120
                C 43 123, 46 125, 50 125
                C 54 125, 57 123, 60 120
                C 65 115, 72 105, 75 95
                C 78 85, 80 75, 80 65
                C 80 55, 75 45, 75 35
                C 75 20, 65 10, 50 10 Z
              " 
              fill="url(#maskGradient)" 
              opacity="0"/>
              
              <!-- Guide points -->
              <circle cx="50" cy="35" r="2" fill="rgba(255,255,255,0.5)"/>
              <circle cx="35" cy="50" r="2" fill="rgba(255,255,255,0.5)"/>
              <circle cx="65" cy="50" r="2" fill="rgba(255,255,255,0.5)"/>
              <circle cx="50" cy="70" r="2" fill="rgba(255,255,255,0.5)"/>
            </svg>
          </div>

          <!-- Corner Brackets -->
          <div class="corner-brackets" id="cornerBrackets">
            <div class="corner top-left"></div>
            <div class="corner top-right"></div>
            <div class="corner bottom-left"></div>
            <div class="corner bottom-right"></div>
          </div>

          <!-- 3D Polygonal Mesh Overlay -->
          <div class="mesh-overlay" id="meshOverlay">
            <canvas id="meshCanvas"></canvas>
          </div>

          <!-- Simple Grid Overlay -->
          <div class="grid-overlay" id="gridOverlay">
            <svg viewBox="0 0 100 100" preserveAspectRatio="none">
              <!-- Vertical lines -->
              <line x1="20" y1="0" x2="20" y2="100" stroke="rgba(195, 255, 0, 0.3)" stroke-width="0.5"/>
              <line x1="40" y1="0" x2="40" y2="100" stroke="rgba(195, 255, 0, 0.3)" stroke-width="0.5"/>
              <line x1="50" y1="0" x2="50" y2="100" stroke="rgba(195, 255, 0, 0.5)" stroke-width="0.8"/>
              <line x1="60" y1="0" x2="60" y2="100" stroke="rgba(195, 255, 0, 0.3)" stroke-width="0.5"/>
              <line x1="80" y1="0" x2="80" y2="100" stroke="rgba(195, 255, 0, 0.3)" stroke-width="0.5"/>
              
              <!-- Horizontal lines -->
              <line x1="0" y1="20" x2="100" y2="20" stroke="rgba(195, 255, 0, 0.3)" stroke-width="0.5"/>
              <line x1="0" y1="40" x2="100" y2="40" stroke="rgba(195, 255, 0, 0.3)" stroke-width="0.5"/>
              <line x1="0" y1="50" x2="100" y2="50" stroke="rgba(195, 255, 0, 0.5)" stroke-width="0.8"/>
              <line x1="0" y1="60" x2="100" y2="60" stroke="rgba(195, 255, 0, 0.3)" stroke-width="0.5"/>
              <line x1="0" y1="80" x2="100" y2="80" stroke="rgba(195, 255, 0, 0.3)" stroke-width="0.5"/>
            </svg>
          </div>

          <!-- Scanning Line -->
          <div class="scan-line" id="scanLine"></div>

          <div class="mask-instructions" id="maskInstructions">
            Position your head within the frame
          </div>
          <div class="capture-countdown" id="captureCountdown">3</div>
        </div>
      </div>
    </div>

    <div class="camera-controls-panel">
      <div class="mode-toggle">
        <span class="mode-label">Manual</span>
        <div class="toggle-switch active" id="modeToggle">
          <div class="toggle-slider"></div>
        </div>
        <span class="mode-label">Auto</span>
      </div>
      
      <button class="capture-button" id="captureButton">
        <i class="fas fa-camera"></i>
        <span id="captureButtonText">Capture Photo</span>
      </button>

      <div class="camera-status">
        <div class="status-indicator">
          <div class="status-dot" id="statusDot"></div>
          <span id="statusText">INITIALIZING...</span>
        </div>
        <div class="progress-bar" id="progressBar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </div>
    </div>

    <div class="flash-overlay" id="flashOverlay"></div>
    <div class="capture-effect" id="captureEffect"></div>
    
    <div class="loading-overlay" id="loadingOverlay">
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <p style="font-size: 1.2rem; color: #c3ff00;">PROCESSING IMAGE...</p>
      </div>
    </div>

    <!-- Confirmation Screen -->
    <div class="confirmation-screen" id="confirmationScreen">
      <div class="confirmation-content">
        <div class="confirmation-header">
          <h2><i class="fas fa-check-circle"></i> Review Your Photo</h2>
          <p>Does this image look good?</p>
        </div>
        
        <div class="preview-image-container">
          <img id="previewImage" src="" alt="Captured photo preview">
        </div>
        
        <div class="confirmation-buttons">
          <button class="confirm-btn confirm-btn-retake" id="retakeButton">
            <i class="fas fa-redo"></i>
            Retake
          </button>
          <button class="confirm-btn confirm-btn-use" id="usePhotoButton">
            <i class="fas fa-check"></i>
            Use This Photo
          </button>
        </div>
      </div>
    </div>

    <script>
      const cameraVideo = document.getElementById('cameraVideo');
      const captureCanvas = document.getElementById('captureCanvas');
      const closeBtn = document.getElementById('closeBtn');
      const cornerBrackets = document.getElementById('cornerBrackets');
      const headMaskContainer = document.getElementById('headMaskContainer');
      const gridOverlay = document.getElementById('gridOverlay');
      const meshOverlay = document.getElementById('meshOverlay');
      const meshCanvas = document.getElementById('meshCanvas');
      const scanLine = document.getElementById('scanLine');
      const maskInstructions = document.getElementById('maskInstructions');
      const captureCountdown = document.getElementById('captureCountdown');
      const loadingOverlay = document.getElementById('loadingOverlay');
      const flashOverlay = document.getElementById('flashOverlay');
      const captureEffect = document.getElementById('captureEffect');
      const statusDot = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      const modeToggle = document.getElementById('modeToggle');
      const captureButton = document.getElementById('captureButton');
      const captureButtonText = document.getElementById('captureButtonText');
      const confirmationScreen = document.getElementById('confirmationScreen');
      const previewImage = document.getElementById('previewImage');
      const retakeButton = document.getElementById('retakeButton');
      const usePhotoButton = document.getElementById('usePhotoButton');
      const detectionCircle = document.getElementById('detectionCircle');
      const detectionLabel = document.getElementById('detectionLabel');

      let cameraStream = null;
      let currentFacingMode = 'user';
      let autoCapture = true;
      let isAligned = false;
      let countdownInterval = null;
      let detectionRunning = false;
      let meshAnimationId = null;
      let capturedImageData = null;

      // Realistic 3D Polygonal Head Mesh Animation
      function initMeshAnimation() {
        const ctx = meshCanvas.getContext('2d');
        let width, height;
        let points = [];
        let time = 0;

        function resizeCanvas() {
          const rect = meshOverlay.getBoundingClientRect();
          width = rect.width;
          height = rect.height;
          meshCanvas.width = width;
          meshCanvas.height = height;
          generateMeshPoints();
        }

        function generateMeshPoints() {
          points = [];
          const rows = 20;
          const cols = 16;
          
          // Create 3D head-shaped mesh
          for (let i = 0; i <= rows; i++) {
            for (let j = 0; j <= cols; j++) {
              const x = (j / cols) * width;
              const y = (i / rows) * height;
              
              // Create head curvature
              const centerX = width / 2;
              const distFromCenter = Math.abs(x - centerX) / (width / 2);
              
              // Head shape: wider in middle, narrower at top and bottom
              let depthFactor = 1;
              if (i < rows * 0.3) {
                // Top of head (narrower)
                depthFactor = 0.7 + (i / (rows * 0.3)) * 0.3;
              } else if (i > rows * 0.7) {
                // Chin area (narrower)
                depthFactor = 1 - ((i - rows * 0.7) / (rows * 0.3)) * 0.4;
              }
              
              const depth = Math.cos(distFromCenter * Math.PI / 2) * 20 * depthFactor;
              
              points.push({
                x: x,
                y: y,
                baseX: x,
                baseY: y,
                depth: depth,
                row: i,
                col: j
              });
            }
          }
        }

        function drawMesh() {
          ctx.clearRect(0, 0, width, height);
          
          const rows = 20;
          const cols = 16;

          // Update points with subtle breathing animation
          time += 0.015;
          points.forEach((point) => {
            const breathe = Math.sin(time + point.row * 0.1) * 2;
            const wave = Math.sin(time * 0.5 + point.baseX * 0.008 + point.baseY * 0.008) * 1.5;
            point.x = point.baseX + wave + breathe * 0.3;
            point.y = point.baseY + wave * 0.5 + breathe * 0.2;
          });

          // Draw polygonal mesh with depth-based coloring
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
              const index = i * (cols + 1) + j;
              const p1 = points[index];
              const p2 = points[index + 1];
              const p3 = points[index + cols + 1];
              const p4 = points[index + cols + 2];

              if (p1 && p2 && p3 && p4) {
                // Calculate depth-based opacity
                const avgDepth = (p1.depth + p2.depth + p3.depth + p4.depth) / 4;
                const opacity = 0.3 + (avgDepth / 40) * 0.5;
                
                // Draw polygon with teal/green gradient
                ctx.strokeStyle = `rgba(20, 184, 166, ${opacity})`;
                ctx.lineWidth = 0.8;
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.closePath();
                ctx.stroke();

                // Add diagonal for triangulation
                ctx.strokeStyle = `rgba(16, 185, 129, ${opacity * 0.5})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.stroke();
              }
            }
          }

          // Draw vertex points for detail
          ctx.fillStyle = 'rgba(20, 184, 166, 0.7)';
          ctx.shadowBlur = 4;
          ctx.shadowColor = 'rgba(20, 184, 166, 0.5)';
          points.forEach((point, index) => {
            if (index % 3 === 0) {
              ctx.beginPath();
              ctx.arc(point.x, point.y, 1.5, 0, Math.PI * 2);
              ctx.fill();
            }
          });
          ctx.shadowBlur = 0;

          meshAnimationId = requestAnimationFrame(drawMesh);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        drawMesh();
      }

      function stopMeshAnimation() {
        if (meshAnimationId) {
          cancelAnimationFrame(meshAnimationId);
          meshAnimationId = null;
        }
      }

      // Start camera on page load
      window.addEventListener('load', () => {
        startCamera();
        initMeshAnimation();
        updateCaptureButtonState();
      });

      // Close button
      closeBtn.addEventListener('click', () => {
        stopCamera();
        window.location.href = '/predict';
      });

      // Mode toggle (Manual/Auto)
      modeToggle.addEventListener('click', () => {
        autoCapture = !autoCapture;
        modeToggle.classList.toggle('active');
        
        if (autoCapture) {
          // Switch to auto mode
          statusText.textContent = 'AUTO MODE - SCANNING...';
          captureButton.disabled = true;
          if (!detectionRunning) {
            startFaceDetection();
          }
        } else {
          // Switch to manual mode
          statusText.textContent = 'MANUAL MODE - READY';
          captureButton.disabled = false;
          detectionRunning = false;
          
          // Reset UI
          isAligned = false;
          updateUIState(false);
          clearInterval(countdownInterval);
          captureCountdown.classList.remove('active');
          progressBar.classList.remove('active');
          progressFill.style.width = '0%';
        }
        
        updateCaptureButtonState();
      });

      // Manual capture button
      captureButton.addEventListener('click', () => {
        if (!autoCapture && !captureButton.disabled) {
          captureImage();
        }
      });

      // Confirmation screen buttons
      usePhotoButton.addEventListener('click', () => {
        saveAndProceed();
      });

      retakeButton.addEventListener('click', () => {
        retakePhoto();
      });

      // Update capture button state
      function updateCaptureButtonState() {
        if (autoCapture) {
          captureButton.disabled = true;
          captureButtonText.textContent = 'Auto Capture Enabled';
          captureButton.style.opacity = '0.5';
        } else {
          captureButton.disabled = false;
          captureButtonText.textContent = 'Capture Photo';
          captureButton.style.opacity = '1';
        }
      }

      // Start camera
      async function startCamera() {
        try {
          statusText.textContent = 'STARTING CAMERA...';
          
          if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
          }

          const constraints = {
            video: {
              facingMode: currentFacingMode,
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          };

          cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
          cameraVideo.srcObject = cameraStream;

          cameraVideo.onloadedmetadata = () => {
            if (autoCapture) {
              statusText.textContent = 'AUTO MODE - SCANNING...';
              statusDot.classList.add('scanning');
              scanLine.classList.add('active');
              
              // Auto-start detection
              if (!detectionRunning) {
                startFaceDetection();
              }
            } else {
              statusText.textContent = 'MANUAL MODE - READY';
              statusDot.classList.add('scanning');
            }
          };
        } catch (error) {
          console.error('Camera access error:', error);
          statusText.textContent = 'CAMERA ERROR';
          alert('Unable to access camera. Please check permissions and try again.');
          window.location.href = '/predict';
        }
      }

      // Stop camera
      function stopCamera() {
        if (cameraStream) {
          cameraStream.getTracks().forEach(track => track.stop());
          cameraStream = null;
        }
        clearInterval(countdownInterval);
        detectionRunning = false;
        stopMeshAnimation();
      }

      // Face detection
      function startFaceDetection() {
        if (detectionRunning) return;
        detectionRunning = true;

        const detectionCanvas = document.createElement('canvas');
        const ctx = detectionCanvas.getContext('2d');
        
        function detectFace() {
          if (!autoCapture || !cameraStream) {
            detectionRunning = false;
            return;
          }

          if (cameraVideo.readyState === cameraVideo.HAVE_ENOUGH_DATA) {
            detectionCanvas.width = cameraVideo.videoWidth;
            detectionCanvas.height = cameraVideo.videoHeight;
            ctx.drawImage(cameraVideo, 0, 0);

            const centerX = detectionCanvas.width / 2;
            const centerY = detectionCanvas.height / 2;
            // Use circular detection zone
            const radius = Math.min(detectionCanvas.width, detectionCanvas.height) * 0.3;
            const maskSize = radius * 2;

            const imageData = ctx.getImageData(
              centerX - radius,
              centerY - radius,
              maskSize,
              maskSize
            );

            const aligned = checkAlignment(imageData, radius);

            if (aligned && !isAligned) {
              isAligned = true;
              updateUIState(true);
              startCountdown();
            } else if (!aligned && isAligned) {
              isAligned = false;
              updateUIState(false);
              clearInterval(countdownInterval);
              captureCountdown.classList.remove('active');
            }
          }

          requestAnimationFrame(detectFace);
        }

        detectFace();
      }

      // Balanced head detection - accurate but not too strict
      function checkAlignment(imageData, radius) {
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        const centerX = width / 2;
        const centerY = height / 2;
        
        let totalBrightness = 0;
        let pixelCount = 0;
        let darkPixels = 0;
        let brightPixels = 0;
        let midTonePixels = 0;
        let skinTonePixels = 0;
        let edgeCount = 0;

        // Check coverage in different regions
        let topCoverage = 0;
        let middleCoverage = 0;
        let bottomCoverage = 0;

        // Sample pixels within circular region
        for (let py = 0; py < height; py += 4) {
          for (let px = 0; px < width; px += 4) {
            // Check if pixel is within circle
            const dx = px - centerX;
            const dy = py - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > radius) continue; // Skip pixels outside circle
            
            const i = (py * width + px) * 4;
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const brightness = (r + g + b) / 3;
          
            // Determine region based on y position
            const yRatio = py / height;
          
            totalBrightness += brightness;
            pixelCount++;

            // Count brightness levels
            if (brightness < 60) darkPixels++;
            else if (brightness > 190) brightPixels++;
            else if (brightness >= 70 && brightness <= 180) midTonePixels++;

            // Detect skin tones (more lenient)
            const isSkinTone = r > g && g > b && 
                              (r - g) < 70 &&
                              r > 80 && r < 240 &&
                              g > 60 && g < 210 &&
                              b > 40 && b < 190;
            
            if (isSkinTone) {
              skinTonePixels++;
              
              // Track coverage by region
              if (yRatio < 0.35) {
                topCoverage++;
              } else if (yRatio < 0.70) {
                middleCoverage++;
              } else {
                bottomCoverage++;
              }
            }

            // Detect edges
            if (i > 160 && i < data.length - 160) {
              const prevBrightness = (data[i-160] + data[i-159] + data[i-158]) / 3;
              if (Math.abs(brightness - prevBrightness) > 20) {
                edgeCount++;
              }
            }
          }
        }

        const avgBrightness = totalBrightness / pixelCount;
        const darkRatio = darkPixels / pixelCount;
        const brightRatio = brightPixels / pixelCount;
        const midToneRatio = midTonePixels / pixelCount;
        const skinToneRatio = skinTonePixels / pixelCount;
        const edgeRatio = edgeCount / pixelCount;

        // Check if head fills the mask (more lenient)
        const topFilled = topCoverage > pixelCount * 0.05;
        const middleFilled = middleCoverage > pixelCount * 0.10;
        const bottomFilled = bottomCoverage > pixelCount * 0.05;
        const maskFilled = topFilled && middleFilled && bottomFilled;

        // Balanced criteria
        const hasGoodBrightness = avgBrightness > 70 && avgBrightness < 175;
        const hasVariation = darkRatio > 0.12 && darkRatio < 0.65;
        const hasEnoughMidTones = midToneRatio > 0.25;
        const hasSkinTones = skinToneRatio > 0.12; // At least 12% skin pixels
        const hasEdges = edgeRatio > 0.08 && edgeRatio < 0.50;
        const notTooUniform = brightRatio < 0.45 && darkRatio < 0.55;

        const isHead = hasGoodBrightness && 
                      hasVariation && 
                      hasEnoughMidTones && 
                      hasSkinTones && 
                      hasEdges && 
                      notTooUniform &&
                      maskFilled;

        // Debug logging
        if (Math.random() < 0.1) {
          console.log('Detection:', {
            aligned: isHead,
            brightness: avgBrightness.toFixed(1),
            skin: (skinToneRatio * 100).toFixed(1) + '%',
            edges: (edgeRatio * 100).toFixed(1) + '%',
            midTones: (midToneRatio * 100).toFixed(1) + '%',
            maskFilled: maskFilled
          });
        }

        return isHead;
      }

      // Countdown
      function startCountdown() {
        let count = 3;
        let progress = 0;
        captureCountdown.textContent = count;
        captureCountdown.classList.add('active');

        countdownInterval = setInterval(() => {
          count--;
          progress += 33.33;
          progressFill.style.width = progress + '%';
          
          if (count > 0) {
            captureCountdown.textContent = count;
            captureCountdown.classList.remove('active');
            setTimeout(() => captureCountdown.classList.add('active'), 10);
            statusText.textContent = `CAPTURING IN ${count}...`;
          } else {
            clearInterval(countdownInterval);
            captureCountdown.classList.remove('active');
            progressFill.style.width = '100%';
            statusText.textContent = 'CAPTURING...';
            captureImage();
          }
        }, 1000);
      }

      // Capture image with realistic effects
      function captureImage() {
        console.log('=== CAPTURE STARTED ===');
        
        // Realistic capture effects
        flashOverlay.classList.add('active');
        captureEffect.classList.add('active');
        
        // Remove effects after animation
        setTimeout(() => {
          flashOverlay.classList.remove('active');
          captureEffect.classList.remove('active');
        }, 500);
        
        // Show loading after flash
        setTimeout(() => {
          loadingOverlay.classList.add('active');
        }, 300);

        const canvas = captureCanvas;
        canvas.width = cameraVideo.videoWidth;
        canvas.height = cameraVideo.videoHeight;
        
        console.log('Canvas size:', canvas.width, 'x', canvas.height);
        
        if (canvas.width === 0 || canvas.height === 0) {
          console.error('Invalid canvas size!');
          alert('Camera not ready. Please try again.');
          loadingOverlay.classList.remove('active');
          return;
        }
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(cameraVideo, 0, 0);

        canvas.toBlob((blob) => {
          if (!blob) {
            console.error('Failed to create blob');
            alert('Failed to capture image. Please try again.');
            loadingOverlay.classList.remove('active');
            return;
          }

          console.log('Blob created:', blob.size, 'bytes');

          const reader = new FileReader();
          reader.onload = (e) => {
            const imageData = e.target.result;
            console.log('Image converted to base64, size:', imageData.length, 'characters');
            
            // Store temporarily for confirmation
            capturedImageData = imageData;
            
            // Hide loading and show confirmation screen
            loadingOverlay.classList.remove('active');
            showConfirmationScreen(imageData);
          };
          
          reader.onerror = (error) => {
            console.error('FileReader error:', error);
            alert('Error reading image. Please try again.');
            loadingOverlay.classList.remove('active');
          };
          
          reader.readAsDataURL(blob);
        }, 'image/jpeg', 0.95);
      }

      // Show confirmation screen
      function showConfirmationScreen(imageData) {
        previewImage.src = imageData;
        confirmationScreen.classList.add('active');
        
        // Pause camera stream
        if (cameraStream) {
          cameraStream.getTracks().forEach(track => track.enabled = false);
        }
      }

      // Save and proceed to predict page
      function saveAndProceed() {
        if (!capturedImageData) {
          alert('No image to save');
          return;
        }

        loadingOverlay.classList.add('active');
        
        // Clear any existing data first
        sessionStorage.removeItem('capturedImage');
        sessionStorage.removeItem('capturedImageName');
        localStorage.removeItem('capturedImage');
        localStorage.removeItem('capturedImageName');
        
        console.log('Cleared old storage');
        
        // Store image with better error handling
        let storageSuccess = false;
        
        try {
          // Try sessionStorage first
          sessionStorage.setItem('capturedImage', capturedImageData);
          sessionStorage.setItem('capturedImageName', 'camera-capture.jpg');
          sessionStorage.setItem('captureTimestamp', Date.now().toString());
          
          // Verify immediately
          const verify = sessionStorage.getItem('capturedImage');
          if (verify && verify.length > 100) {
            console.log(' SessionStorage SUCCESS - Size:', verify.length);
            storageSuccess = true;
          } else {
            console.warn('SessionStorage verification failed');
          }
        } catch (error) {
          console.error('SessionStorage error:', error.message);
        }
        
        // Fallback to localStorage if sessionStorage failed
        if (!storageSuccess) {
          try {
            console.log('Trying localStorage fallback...');
            localStorage.setItem('capturedImage', capturedImageData);
            localStorage.setItem('capturedImageName', 'camera-capture.jpg');
            localStorage.setItem('captureTimestamp', Date.now().toString());
            
            const verify = localStorage.getItem('capturedImage');
            if (verify && verify.length > 100) {
              console.log(' LocalStorage SUCCESS - Size:', verify.length);
              storageSuccess = true;
            }
          } catch (localError) {
            console.error('LocalStorage error:', localError.message);
          }
        }
        
        if (!storageSuccess) {
          console.error(' STORAGE FAILED!');
          alert('Failed to save image. Please try again.');
          loadingOverlay.classList.remove('active');
          return;
        }
        
        // Stop camera
        stopCamera();
        console.log('Camera stopped');
        
        // Redirect
        console.log('Redirecting to predict page...');
        setTimeout(() => {
          console.log('=== REDIRECTING NOW ===');
          window.location.href = '/predict';
        }, 300);
      }

      // Retake photo - redirect back to camera page
      function retakePhoto() {
        confirmationScreen.classList.remove('active');
        capturedImageData = null;
        
        // Clear storage
        sessionStorage.removeItem('capturedImage');
        sessionStorage.removeItem('capturedImageName');
        sessionStorage.removeItem('captureTimestamp');
        localStorage.removeItem('capturedImage');
        localStorage.removeItem('capturedImageName');
        localStorage.removeItem('captureTimestamp');
        
        // Reload the camera page
        window.location.reload();
      }

      // Update UI state based on detection
      function updateUIState(aligned) {
        if (aligned) {
          // Update UI for aligned state
          document.querySelector('.camera-view').classList.add('detecting');
          document.querySelectorAll('.corner').forEach(corner => {
            corner.classList.add('aligned');
          });
          detectionCircle.classList.add('aligned');
          detectionLabel.classList.add('aligned');
          detectionLabel.innerHTML = '<i class="fas fa-check-circle"></i><br>Head Detected!';
          headMaskContainer.classList.add('aligned');
          gridOverlay.classList.add('aligned');
          meshOverlay.classList.add('active');
          maskInstructions.classList.add('ready');
          maskInstructions.textContent = 'HEAD DETECTED - HOLD STILL';
          statusText.textContent = 'HEAD DETECTED';
          progressBar.classList.add('active');
        } else {
          // Reset UI
          document.querySelector('.camera-view').classList.remove('detecting');
          document.querySelectorAll('.corner').forEach(corner => {
            corner.classList.remove('aligned');
          });
          detectionCircle.classList.remove('aligned');
          detectionLabel.classList.remove('aligned');
          detectionLabel.innerHTML = '<i class="fas fa-head-side-virus"></i><br>Position Head/Scalp Here';
          headMaskContainer.classList.remove('aligned');
          gridOverlay.classList.remove('aligned');
          meshOverlay.classList.remove('active');
          maskInstructions.classList.remove('ready');
          maskInstructions.textContent = 'Position your head within the frame';
          statusText.textContent = autoCapture ? 'AUTO MODE - SCANNING...' : 'MANUAL MODE - READY';
          progressBar.classList.remove('active');
          progressFill.style.width = '0%';
        }
      }
    </script>
  </body>
</html>
